<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>H-Space similarity explorer</title>
<style>
  * {
    margin: 0;
    padding: 0;
    font-family: Arial, sans-serif;
  }
  #intro {
    margin: 1em auto 2em auto;
    width: 100%;
    max-width: 800px;
  }
  #intro p {
    margin: 1em;
    line-height: 1.2em;
  }
  #canvas-container {
    margin: 0 auto;
    margin-bottom: 2em;
    width: 100%;
    max-width: 800px;
  }
  #canvas-container div {
    width: 100%;
    margin: 2em 0 0 0;
  }
  #canvas-container div div {
    display: inline-block;
    max-width: 44.9%;
    margin: 0 2.5%;
  }
  #canvas-container p {
    text-align: center;
    margin-bottom: .2em;
  }
  #canvas-container p input {
    margin: 0 .5em 0 .5em;
    height: .8em;
    max-width: 80%;
  }
  canvas {
    border: 1px solid #000;
    max-width: 100%;
    height: auto;
    display: block;
    touch-action: none;
  }
</style>
</head>
<body>
  <div id="intro">
    <h1 style="text-align: center;">H-Space similarity explorer</h1>
    <p>
      This is a simple tool to explore the similarity between the representations of different concepts at different spatial positions in the h-space of diffusion models.
      The examples below are for Stable Diffusion 1.5, which has a h-space dimension of (50, 1280, 8, 8), i.e. 50 steps, 1280 channels, and 8x8 spatial resolution.
    </p>
    <p>
      All displayed similarities are relative to the currently hovered, or last clicked, tile.
    </p>
    <p>
      Similarity measure:
      <select id="similarity-measure">
        <option value="cosine">Cosine</option>
        <option value="euclidean">Euclidean</option>
        <option value="manhattan">Manhattan</option>
      </select>
      
    </p>
  </div>
  <div id="canvas-container"></div>
  <script>

const GRID_SIZE = 8;
let last_tile = null;  // remember the last tile to avoid redundant updates
let last_clicked = { concept_id: 0, col: 0, row: 0 };  // remember the last clicked tile
const available_concepts = [];
const concepts = [];
const initial_concepts = [
  { name: 'Cat', initial_step: 50, },
  { name: 'Dog', initial_step: 50, },
  { name: 'Dog', initial_step: 32, },
];



function createElem(tag, attrs, parent) {
  const elem = document.createElement(tag);
  for (const [key, value] of Object.entries(attrs)) {
    elem[key] = value;
  }
  parent.appendChild(elem);
  return elem;
}



function setupConcept({ name, initial_step }, i) {
  const self = { id: i, name: name, step: initial_step };
  const img_path = `representations/${name}/`;
  const bin_path = `representations/${name}/repr.bin`;
  // create html elements
  const canvas_container = document.getElementById('canvas-container');
  const canvas_row = createElem('div', {}, canvas_container);
  const image_canvas_div = createElem('div', {}, canvas_row);
  const canvas_size = image_canvas_div.clientWidth * 2;
  const title_p = createElem('p', {}, image_canvas_div);
  createElem('span', { textContent: `${name}, step:` }, title_p);
  const slider = createElem('input', { type: 'range', min: '1', max: '50', value: self.step }, title_p);
  const slider_value = createElem('span', { textContent: self.step }, title_p);
  self.image_canvas = createElem('canvas', { width: canvas_size, height: canvas_size }, image_canvas_div);
  const tile_canvas_div = createElem('div', {}, canvas_row);
  const text_p = createElem('p', {}, tile_canvas_div);
  createElem('span', { textContent: `Similarities, avg: ` }, text_p);
  self.text = createElem('span', { textContent: `?` }, text_p);
  self.tile_canvas = createElem('canvas', { width: canvas_size, height: canvas_size }, tile_canvas_div);

  // slider event listener
  slider.addEventListener('input', event => {
    const value = event.target.value;
    slider_value.textContent = value;
    self.step = value;
    self.img.src = img_path + `${self.step}.png`;
    last_tile = null;
    updateCanvases(concepts[last_clicked.concept_id], last_clicked.col, last_clicked.row);
  });

  self.image_ctx = self.image_canvas.getContext('2d');
  self.tile_ctx = self.tile_canvas.getContext('2d');
  self.img = new Image();
  
  self.img.src = img_path + `${self.step}.png`;
  self.img.onload = function() {
    self.image_ctx.globalCompositeOperation = 'destination-over';
    self.image_ctx.drawImage(self.img, 0, 0, self.image_ctx.canvas.width, self.image_ctx.canvas.height);
    self.image_ctx.globalCompositeOperation = 'source-over';
  }
  let repr = null;
  fetch(bin_path)
    .then(response => response.arrayBuffer())
    .then(buffer => {
      const repr = new Float32Array(buffer);
      console.log(`Fetched repr from ${bin_path} with length ${repr.length}`);
      self.repr = repr;
    });
  return self;
}



function cosineSimilarity(repr1, offset1, repr2, offset2) {
  let dotProduct = 0.0;
  let normA = 0.0;
  let normB = 0.0;

  for (let i = 0; i < 1280; i++) {
    const i1 = offset1 + i*8*8;
    const i2 = offset2 + i*8*8;
    // if (i1 >= 81920 || i2 >= 81920) {
    //   console.error(`index too high: i1: ${i1}, i2: ${i2}`);
    // }
    // if (isNaN(repr1[i1]) || isNaN(repr2[i2])) {
    //   console.error(`NaN: i1: ${i1}, i2: ${i2}, repr1[i1]: ${repr1[i1]}, repr2[i2]: ${repr2[i2]}`);
    // }
    dotProduct += repr1[i1] * repr2[i2];
    normA += repr1[i1] * repr1[i1];
    normB += repr2[i2] * repr2[i2];
  }

  normA = Math.sqrt(normA);
  normB = Math.sqrt(normB);

  if (normA === 0 || normB === 0) {
    throw new Error('One of the vectors is zero');
  }

  return dotProduct / (normA * normB);
}


function euclideanDistance(repr1, offset1, repr2, offset2) {
  let sum = 0.0;
  for (let i = 0; i < 1280; i++) {
    const i1 = offset1 + i*8*8;
    const i2 = offset2 + i*8*8;
    sum += Math.pow(repr1[i1] - repr2[i2], 2);
  }

  return Math.sqrt(sum);
}


function manhattanDistance(repr1, offset1, repr2, offset2) {
  let sum = 0.0;
  for (let i = 0; i < 1280; i++) {
    const i1 = offset1 + i*8*8;
    const i2 = offset2 + i*8*8;
    sum += Math.abs(repr1[i1] - repr2[i2]);
  }
  return sum;
}


function calcSimilarities(base_concept, col, row, concept) {
  const calc = measure => {
    const x = [];
    for (let i = 0; i < GRID_SIZE; i++) {
      for (let j = 0; j < GRID_SIZE; j++) {
        const offset1 = base_concept.step*1280*8*8 + row*8 + col;
        const offset2 = concept.step*1280*8*8 + j*8 + i;
        const similarity = measure(base_concept.repr, offset1, concept.repr, offset2);
        x.push(similarity);
      }
    }
    return x;
  }
  const measure_str = document.getElementById('similarity-measure').value;
  if (measure_str === 'cosine') {
    return calc(cosineSimilarity);
  } else if (measure_str === 'euclidean') {
    const differences =  calc(euclideanDistance);
    const max = Math.max(...differences);
    return differences.map(x => 1 - x / max);
  } else if (measure_str === 'manhattan') {
    const differences = calc(manhattanDistance);
    const max = Math.max(...differences);
    return differences.map(x => 1 - x / max);
  }
}



// Utility function to load an image
function loadImage(ctx, img) {
  ctx.drawImage(img, 0, 0, ctx.canvas.width, ctx.canvas.height);
}

// Function to draw the grid
function drawGrid(ctx) {
  const tile_size = ctx.canvas.width / GRID_SIZE;
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.beginPath();

  // Draw the vertical lines
  for (let i = 1; i < GRID_SIZE; i++) {
    ctx.moveTo(i * tile_size, 0);
    ctx.lineTo(i * tile_size, ctx.canvas.height);
  }

  // Draw the horizontal lines
  for (let i = 1; i < GRID_SIZE; i++) {
    ctx.moveTo(0, i * tile_size);
    ctx.lineTo(ctx.canvas.width, i * tile_size);
  }

  ctx.stroke();
}


// Event listener for mouse movement over canvas
function updateCanvases(base_concept, col, row) {
  // Check if the mouse is inside the canvas
  if (col < 0 || col >= GRID_SIZE || row < 0 || row >= GRID_SIZE) return;

  // Check if the tile has changed
  const curr_tile = `${base_concept.id}-${col}-${row}`;
  if (curr_tile === last_tile) return;
  last_tile = curr_tile;

  // Update the canvases
  for (const concept of concepts) {
    const tile_size = concept.image_ctx.canvas.width / GRID_SIZE;
    // update image canvas
    const img_ctx = concept.image_ctx;
    img_ctx.clearRect(0, 0, img_ctx.canvas.width, img_ctx.canvas.height);
    loadImage(img_ctx, concept.img);
    drawGrid(img_ctx);
    if (concept === base_concept) {
      img_ctx.strokeStyle = 'rgba(255, 165, 0, 1)';
      img_ctx.lineWidth = 2;
      img_ctx.strokeRect(col * tile_size, row * tile_size, tile_size, tile_size);
      img_ctx.fillStyle = 'rgba(255, 165, 0, 0.7)';
      img_ctx.fillRect(col * tile_size, row * tile_size, tile_size, tile_size);
    }
    if (last_clicked.concept_id === concept.id && !(last_clicked.col === col && last_clicked.row === row && concept === base_concept)) {
      img_ctx.fillStyle = 'rgba(255, 165, 165, 0.7)';
      img_ctx.fillRect(last_clicked.col * tile_size, last_clicked.row * tile_size, tile_size, tile_size);
    }
    // update tile canvas
    const similarities = calcSimilarities(base_concept, col, row, concept);
    concept.tile_ctx.clearRect(0, 0, concept.tile_ctx.canvas.width, concept.tile_ctx.canvas.height);
    for (let i = 0; i < GRID_SIZE; i++) {
      for (let j = 0; j < GRID_SIZE; j++) {
        const similarity = similarities[i * GRID_SIZE + j];
        concept.tile_ctx.fillStyle = similarity > 0 ? `rgba(255, 165, 0, ${similarity})` : `rgba(0, 165, 255, ${-similarity})`;
        concept.tile_ctx.fillRect(i * tile_size, j * tile_size, tile_size, tile_size);
      }
    }

    const averageSimilarity = similarities.reduce((a, b) => a + b, 0) / similarities.length;
    concept.text.textContent = `${averageSimilarity.toFixed(4)}`;
  }
}

function getMousePos(canvas, event) {
  if (event.touches) event = event.touches[0];  // handle touch events for mobile
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  const col = Math.floor(2 * x / canvas.width * GRID_SIZE);
  const row = Math.floor(2 * y / canvas.width * GRID_SIZE);
  return { col, row };
}


function init() {
  // setup concepts
  fetch('representations/outputs.txt')
    .then(response => response.text())
    .then(text => {
      text.split('\n').forEach((name, i) => {
        available_concepts.push({ name, initial_step: 50 });
      });
    })
    .then(() => {
      initial_concepts.forEach((x, i) => {
        concepts.push(setupConcept(x, i));
      });
    })
    .then(() => {
      concepts.forEach((concept, concept_index) => {
        loadImage(concept.image_ctx, concept.img);
        drawGrid(concept.image_ctx);
        [concept.image_canvas, concept.tile_canvas].forEach(canvas => {
          const moveHandler = function(event) {
            const { col, row } = getMousePos(canvas, event);
            updateCanvases(concept, col, row);
          };
          const leaveHandler = function(event) {
            updateCanvases(concepts[last_clicked.concept_id], last_clicked.col, last_clicked.row);
          };
          const clickHandler = function(event) {
            const { col, row } = getMousePos(canvas, event);
            last_clicked.concept_id = concept.id;
            last_clicked.col = col;
            last_clicked.row = row;
            last_tile = null;  // force update
            updateCanvases(concept, col, row);
          };
          canvas.addEventListener('click', clickHandler);
          canvas.addEventListener('mousemove', moveHandler);
          canvas.addEventListener('mouseleave', leaveHandler);
          canvas.addEventListener('touchstart', clickHandler);
          canvas.addEventListener('touchmove', clickHandler);
        });
      });
    });

  // setup similarity measure change event listener
  document.getElementById('similarity-measure').addEventListener('change', event => {
    last_tile = null;
    updateCanvases(concepts[last_clicked.concept_id], last_clicked.col, last_clicked.row);
  });

  // reload on resize to update canvas size
  window.addEventListener('resize', () => {
      concepts.forEach(concept => {
        const canvas_size = concept.image_ctx.canvas.parentElement.clientWidth * 2;
        concept.image_canvas.width = canvas_size;
        concept.image_canvas.height = canvas_size;
        concept.tile_canvas.width = canvas_size;
        concept.tile_canvas.height = canvas_size;
        loadImage(concept.image_ctx, concept.img);
        drawGrid(concept.image_ctx);
        updateCanvases(concept, last_clicked.col, last_clicked.row);
      });
  });

}


init();

</script>

</body>
</html>
