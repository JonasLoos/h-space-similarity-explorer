<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>H-Space similarity explorer</title>
<style>
* {
  margin: 0;
  padding: 0;
  font-family: Arial, sans-serif;
}
#intro {
  margin: 1em auto 2em auto;
  width: 100%;
  max-width: 800px;
}
#intro p {
  margin: 1em;
  line-height: 1.2em;
}
.select-container {
  margin: .5em;
  display: flex;
  flex-wrap: wrap;
}
.select-group {
  margin: .5em;
}
.select-group span {
  margin-right: .3em;
}
#canvas-container {
  margin: 0 auto;
  margin-bottom: 2em;
  width: 100%;
  max-width: 800px;
}
#canvas-container h2 {
  text-align: center;
  margin: 2em 0 0 0;
}
#canvas-container h2 select {
  margin: 1em;
}
#canvas-container>p {
  text-align: center;
  color: grey;
}
#canvas-container div {
  width: 100%;
}
#canvas-container div div {
  display: inline-block;
  max-width: 44.9%;
  margin: 0 2.5%;
}
#canvas-container p {
  text-align: center;
  margin-bottom: .2em;
}
#canvas-container p input {
  margin: 0 .5em 0 .5em;
  height: .8em;
  max-width: 80%;
}
canvas {
  border: 1px solid #000;
  max-width: 100%;
  height: auto;
  display: block;
  touch-action: none;
}
</style>
</head>
<body>
  <div id="intro">
    <h1 style="text-align: center;">H-Space similarity explorer</h1>
    <p>
      This is a simple tool to explore the similarity between the representations of different concepts at different spatial positions in the h-space of diffusion models.
      The h-space is the output of the midblock of the diffusion unet, however, you can also explore the output from other positions in the unet.
      If you want to try this for your own prompts, check out the source code <a href="https://github.com/JonasLoos/h-space-similarity-explorer">here</a>.
    </p>
    <div class="select-container">
      <div class="select-group">
        <span>Model:</span>
        <select id="model-to-use"></select>
      </div>
      <div class="select-group">
        <span>Position:</span>
        <select id="position-to-use"></select>
      </div>
      <div class="select-group">
        <span>Similarity measure:</span>
        <select id="similarity-measure">
          <option value="cosine">Cosine</option>
          <option value="cosine_centered">Cosine (centered)</option>
          <!-- <option value="soft_cosine">Soft Cosine</option> -->
          <option value="manhattan">Manhattan (L1)</option>
          <option value="euclidean">Euclidean (L2)</option>
          <option value="chebyshev">Chebyshev (Lâˆž)</option>
        </select>
      </div>
    </div>    
    <p id="model-description">
    </p>
    <p>
      All displayed similarities are relative to the currently hovered, or last clicked, tile.
    </p>
  </div>
  <div id="canvas-container"></div>
  <script>

// initialize variables
let last_tile = null;  // remember the last tile to avoid redundant updates
let last_clicked = { concept_id: 0, col: 9, row: 6 };  // remember the last clicked tile
const available_models = [];
let current_model = null;
let available_positions = {};
let current_position = 'mid_block';  // assuming mid_block is always available
const available_concepts = [];
const concepts = [];
const initial_concepts = [
  { index: 0, initial_step: 4, },
  { index: 1, initial_step: 4, },
  { index: 1, initial_step: 2, },
];


// create an html element with attributes and append it to a parent
function createElem(tag, attrs, parent) {
  const elem = document.createElement(tag);
  for (const [key, value] of Object.entries(attrs)) {
    elem[key] = value;
  }
  parent.appendChild(elem);
  return elem;
}


// setup a concept with its canvas elements and event listeners
function setupConcept({ index, initial_step }, i) {
  const { name, prompt } = available_concepts[index];
  const concept = { id: i, name: name, step: initial_step };
  // create html elements
  const canvas_container = document.getElementById('canvas-container');
  const title_elem = createElem('h2', {}, canvas_container)
  const title_text = createElem('span', { textContent: name }, title_elem);
  const title_select = createElem('select', { id: `concept-${i}-select` }, title_elem);
  available_concepts.forEach((concept, i) => {
    const option = createElem('option', { value: concept.name, textContent: concept.name }, title_select);
    if (concept.name === name) option.selected = true;
  });
  const prompt_p = createElem('p', { textContent: `Prompt: ${prompt}` }, canvas_container);
  const canvas_row = createElem('div', {}, canvas_container);
  const image_canvas_div = createElem('div', {}, canvas_row);
  const canvas_size = image_canvas_div.clientWidth * 2;
  const title_p = createElem('p', {}, image_canvas_div);
  createElem('span', { textContent: `Image at step:` }, title_p);
  const slider = createElem('input', { type: 'range', min: '1', max: current_model.steps, value: concept.step }, title_p);
  const slider_value = createElem('span', { textContent: concept.step }, title_p);
  concept.image_canvas = createElem('canvas', { width: canvas_size, height: canvas_size }, image_canvas_div);
  const tile_canvas_div = createElem('div', {}, canvas_row);
  const text_p = createElem('p', {}, tile_canvas_div);
  createElem('span', { textContent: `Similarities, avg: ` }, text_p);
  concept.text = createElem('span', { textContent: `?` }, text_p);
  concept.tile_canvas = createElem('canvas', { width: canvas_size, height: canvas_size }, tile_canvas_div);

  // get convas contexts
  concept.image_ctx = concept.image_canvas.getContext('2d');
  concept.tile_ctx = concept.tile_canvas.getContext('2d');

  // helper function to load the representation
  const getRepr = () => {
    concept.repr = null;
    fetch(`representations/${current_model.short}/${concept.name}/repr-${current_position}.bin`)
      .then(response => response.arrayBuffer())
      .then(buffer => {

        // store representation
        const repr = new Float32Array(buffer);
        const num_nans = repr.reduce((a, b) => a + (isNaN(b) ? 1 : 0), 0);
        console.log(`Fetched repr for ${concept.name} with length ${repr.length} with ${num_nans} NaNs`);
        concept.repr = repr;

        // calculate means
        const { steps, m, n } = current_model.getShapes();
        const means = new Float32Array(m*steps);
        for (let step = 0; step < steps; step++) {
          for (let i = 0; i < m; i++) {
            const i_base = step*m + i;
            const i_repr = (step*m + i)*n*n;
            for (let j = 0; j < n*n; j++) {
              means[i_base] += repr[i_repr + j];
            }
            means[i_base] /= n*n;
          }
          concept.repr_means = means;
        }

        // update convases as the representations are available now
        updateCanvasesWithLastClicked();
      });
  };

  // update
  concept.update = () => {
    // setup prompt related elements
    const prompt = available_concepts.find(x => x.name === concept.name).prompt;
    title_text.textContent = concept.name;
    prompt_p.textContent = prompt;

    // update slider
    concept.step = Math.max(Math.round(concept.step / slider.max * current_model.steps), 1)  // update step to match new model
    slider.max = current_model.steps;
    slider.value = concept.step;
    slider_value.textContent = concept.step;

    // update image und representation
    concept.img.src = `representations/${current_model.short}/${concept.name}/${concept.step}.jpg`;
    getRepr();
  }

  // load image
  concept.img = new Image();  
  concept.img.src = `representations/${current_model.short}/${concept.name}/${concept.step}.jpg`;
  concept.img.onload = function() {
    concept.image_ctx.globalCompositeOperation = 'destination-over';
    concept.image_ctx.drawImage(concept.img, 0, 0, concept.image_ctx.canvas.width, concept.image_ctx.canvas.height);
    concept.image_ctx.globalCompositeOperation = 'source-over';
    updateCanvasesWithLastClicked();
  }

  // load representation
  getRepr();

  // setup event listeners  
  [concept.image_canvas, concept.tile_canvas].forEach(canvas => {
    const moveHandler = function(event) {
      const { col, row } = getMousePos(canvas, event);
      updateCanvases(concept, col, row);
    };
    const leaveHandler = function(event) {
      updateCanvases(concepts[last_clicked.concept_id], last_clicked.col, last_clicked.row);
    };
    const clickHandler = function(event) {
      const { col, row } = getMousePos(canvas, event);
      last_clicked.concept_id = concept.id;
      last_clicked.col = col;
      last_clicked.row = row;
      last_tile = null;  // force update
      updateCanvases(concept, col, row);

      // log clicked tile
      const { m, n } = current_model.getShapes();
      const block_repr = [];
      for (let i = 0; i < m; i++) {
        block_repr.push(concept.repr[(concept.step-1)*m*n*n + i*n*n + row*n + col]);
      }
      console.log(`Clicked on ${concept.name} at (${col},${row})`, block_repr);
    };
    canvas.addEventListener('click', clickHandler);
    canvas.addEventListener('mousemove', moveHandler);
    canvas.addEventListener('mouseleave', leaveHandler);
    canvas.addEventListener('touchstart', clickHandler);
    canvas.addEventListener('touchmove', clickHandler);
  });
  
  // slider event listener
  slider.addEventListener('input', event => {
    const value = event.target.value;
    slider_value.textContent = value;
    concept.step = value;
    concept.img.src = `representations/${current_model.short}/${concept.name}/${concept.step}.jpg`;
    updateCanvasesWithLastClicked();
  });

  // concept name select event listener
  title_select.addEventListener('change', event => {
    const value = event.target.value;
    concept.name = value;
    concept.update();
  });

  // concept is ready
  return concept;
}



// calculate the cosine similarity between two representations
function cosineSimilarity(repr1, offset1, repr2, offset2) {

  // init
  const { m, n } = current_model.getShapes();
  let dotProduct = 0.0;
  let normA = 0.0;
  let normB = 0.0;

  for (let i = 0; i < m; i++) {
    const i1 = offset1 + i*n*n;
    const i2 = offset2 + i*n*n;
    dotProduct += repr1[i1] * repr2[i2];
    normA += repr1[i1] * repr1[i1];
    normB += repr2[i2] * repr2[i2];
  }

  normA = Math.sqrt(normA);
  normB = Math.sqrt(normB);

  if (normA === 0 || normB === 0) {
    console.error('One of the vectors is zero');
    console.log('m:', m, 'n:', n, 'dotProduct:', dotProduct, 'normA:', normA, 'normB:', normB);
    return NaN;
  }

  return dotProduct / (normA * normB);
}


// calculate the soft cosine similarity between two representations
// with similarity matrix $s_{ij} := min(|a_i-a_j|,|b_i-b_j|) / (max(|a_i-a_j|,|b_i-b_j|) + \epsilon)$
// this is slow, tends to nan and doesn't really seem to work
function softCosineSimilarity(repr1, offset1, repr2, offset2) {

  // init
  const { m, n } = current_model.getShapes();
  let dotProduct = 0.0;
  let normA = 0.0;
  let normB = 0.0;

  // get max values for regulatization for numerical stability
  let max = 0.0;
  for (let i = 0; i < m; i++) {
    const i1 = offset1 + i*n*n;
    const i2 = offset2 + i*n*n;
    max = Math.max(max, Math.abs(repr1[i1]), Math.abs(repr2[i2]));
  }

  // TODO: two nested loops are very slow
  for (let i = 0; i < m; i++) {
    const i1 = offset1 + i*n*n;
    const i2 = offset2 + i*n*n;
    const x1i = repr1[i1] / max;
    const x2i = repr2[i2] / max;
    for (let j = 0; j < m; j++) {
      const j1 = offset1 + j*n*n;
      const j2 = offset2 + j*n*n;
      const x1j = repr1[j1] / max;
      const x2j = repr2[j2] / max;
      const diff1 = Math.abs(x1i - x1j);
      const diff2 = Math.abs(x2i - x2j);
      const element_similarity = i==j || Math.min(diff1, diff2) / ((Math.max(diff1, diff2)) + 1e-10);
      dotProduct += element_similarity * x1i * x2j;
      normA += element_similarity * x1i * x1j;
      normB += element_similarity * x2i * x2j;
    }
  }

  normA = Math.sqrt(normA);
  normB = Math.sqrt(normB);

  if (normA === 0 || normB === 0) {
    throw new Error('One of the vectors is zero');
  }

  return dotProduct / (normA * normB) * max;
}


// center the representations and then calculate cosine similarity
function centeredCosineSimilarity(repr1, offset1, means1, repr2, offset2, means2) {

  // init
  const { m, n } = current_model.getShapes();
  let dotProduct = 0.0;
  let normA = 0.0;
  let normB = 0.0;

  // calculate centered cosine similarity
  for (let i = 0; i < m; i++) {
    const i1 = offset1 + i*n*n;
    const i2 = offset2 + i*n*n;
    const mean = (means1[i] + means2[i]) / 2;  // use the mean over both representations
    dotProduct += (repr1[i1] - mean) * (repr2[i2] - mean);
    normA += Math.pow(repr1[i1] - mean, 2);
    normB += Math.pow(repr2[i2] - mean, 2);
  }

  normA = Math.sqrt(normA);
  normB = Math.sqrt(normB);

  if (normA === 0 || normB === 0) {
    throw new Error('One of the vectors is zero');
  }

  return dotProduct / (normA * normB);
}


// calculate the euclidean distance (L1) between two representations
function euclideanDistance(repr1, offset1, repr2, offset2) {
  const { m, n } = current_model.getShapes();
  let sum = 0.0;
  for (let i = 0; i < m; i++) {
    const i1 = offset1 + i*n*n;
    const i2 = offset2 + i*n*n;
    sum += Math.pow(repr1[i1] - repr2[i2], 2);
  }

  return Math.sqrt(sum);
}


// calculate the manhattan distance (L2) between two representations
function manhattanDistance(repr1, offset1, repr2, offset2) {
  const { m, n } = current_model.getShapes();
  let sum = 0.0;
  for (let i = 0; i < m; i++) {
    const i1 = offset1 + i*n*n;
    const i2 = offset2 + i*n*n;
    sum += Math.abs(repr1[i1] - repr2[i2]);
  }
  return sum;
}


// calculate the chebyshev distance (Lâˆž) between two representations
function chebyshevDistance(repr1, offset1, repr2, offset2) {
  const { m, n } = current_model.getShapes();
  let max = 0.0;
  for (let i = 0; i < m; i++) {
    const i1 = offset1 + i*n*n;
    const i2 = offset2 + i*n*n;
    const diff = Math.abs(repr1[i1] - repr2[i2]);
    if (diff > max) max = diff;
  }
  return max;
}


// calculate similarities based on the selected similarity measure and tile
function calcSimilarities(base_concept, col, row, concept) {
  const { m, n } = current_model.getShapes();
  const step1 = base_concept.step - 1;
  const step2 = concept.step - 1;

  // check if representations are loaded
  if (!base_concept.repr || !concept.repr) {
    console.log(`Representations not loaded (base_concept: ${!!base_concept.repr}, other concept: ${!!concept.repr})`);
    return Array(n*n).fill(0);
  }

  // helper function to calculate similarities for all tiles
  const calc = measure => {
    const x = [];
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        const offset1 = step1*m*n*n + row*n + col;
        const offset2 = step2*m*n*n + j*n + i;
        const similarity = measure(base_concept.repr, offset1, concept.repr, offset2);
        x.push(similarity);
      }
    }
    return x;
  }

  // calculate similarities
  const measure_str = document.getElementById('similarity-measure').value;
  if (measure_str === 'cosine') {
    return calc(cosineSimilarity);
  } else if (measure_str === 'soft_cosine') {
    return calc(softCosineSimilarity);
  } else if (measure_str === 'cosine_centered') {
    return calc((r1,o1,r2,o2) => centeredCosineSimilarity(r1,o1,base_concept.repr_means.subarray(step1*m,step1*m+m),r2,o2,concept.repr_means.subarray(step2*m,step2*m+m)));
  } else if (measure_str === 'euclidean') {
    const differences =  calc(euclideanDistance);
    const max = Math.max(...differences);
    return differences.map(x => 1 - x / max);
  } else if (measure_str === 'manhattan') {
    const differences = calc(manhattanDistance);
    const max = Math.max(...differences);
    return differences.map(x => 1 - x / max);
  } else if (measure_str === 'chebyshev') {
    const differences = calc(chebyshevDistance);
    const max = Math.max(...differences);
    return differences.map(x => 1 - x / max);
  }
}


// Function to draw the grid
function drawGrid(ctx) {
  const { n } = current_model.getShapes();
  const tile_size = ctx.canvas.width / n;
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.beginPath();

  // Draw the vertical lines
  for (let i = 1; i < n; i++) {
    ctx.moveTo(i * tile_size, 0);
    ctx.lineTo(i * tile_size, ctx.canvas.height);
  }

  // Draw the horizontal lines
  for (let i = 1; i < n; i++) {
    ctx.moveTo(0, i * tile_size);
    ctx.lineTo(ctx.canvas.width, i * tile_size);
  }

  ctx.stroke();
}


// Update the canvas highlightings based on the mouse position
function updateCanvases(base_concept, col, row) {
  const { n } = current_model.getShapes();
  // Check if the mouse is inside the canvas
  if (col < 0 || col >= n || row < 0 || row >= n) return;

  // Check if the tile has changed
  const curr_tile = `${base_concept.id}-${col}-${row}`;
  if (curr_tile === last_tile) return;
  last_tile = curr_tile;

  // Update the canvases
  for (const concept of concepts) {
    const tile_size = concept.image_ctx.canvas.width / n;
    // update image canvas
    const img_ctx = concept.image_ctx;
    img_ctx.clearRect(0, 0, img_ctx.canvas.width, img_ctx.canvas.height);
    img_ctx.drawImage(concept.img, 0, 0, img_ctx.canvas.width, img_ctx.canvas.height);
    drawGrid(img_ctx);
    if (concept === base_concept) {
      // highlight the currently selected tile
      img_ctx.strokeStyle = 'rgba(255, 165, 0, 1)';
      img_ctx.lineWidth = 2;
      img_ctx.strokeRect(col * tile_size, row * tile_size, tile_size, tile_size);
      img_ctx.fillStyle = 'rgba(255, 165, 0, 0.7)';
      img_ctx.fillRect(col * tile_size, row * tile_size, tile_size, tile_size);
    }
    if (last_clicked.concept_id === concept.id && !(last_clicked.col === col && last_clicked.row === row && concept === base_concept)) {
      // highlight the last clicked tile
      img_ctx.fillStyle = 'rgba(255, 165, 165, 0.7)';
      img_ctx.fillRect(last_clicked.col * tile_size, last_clicked.row * tile_size, tile_size, tile_size);
    }
    // update tile canvas
    const similarities = calcSimilarities(base_concept, col, row, concept);
    concept.tile_ctx.clearRect(0, 0, concept.tile_ctx.canvas.width, concept.tile_ctx.canvas.height);
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        const similarity = similarities[i * n + j];
        concept.tile_ctx.fillStyle = similarity > 0 ? `rgba(255, 165, 0, ${similarity})` : `rgba(0, 165, 255, ${-similarity})`;
        concept.tile_ctx.fillRect(i * tile_size, j * tile_size, tile_size, tile_size);
      }
    }

    // calculate and update average similarity
    const averageSimilarity = similarities.reduce((a, b) => a + b, 0) / similarities.length;
    concept.text.textContent = `${averageSimilarity.toFixed(4)}`;
  }
}


// force update of all canvases with the last clicked tile as the base
function updateCanvasesWithLastClicked() {
  console.log('updateCanvasesWithLastClicked')
  last_tile = null;  // force update
  updateCanvases(concepts[last_clicked.concept_id], last_clicked.col, last_clicked.row);
}



function updatePositionSelector() {
  if (current_model.representations[current_position] === undefined) current_position = 'mid_block';  // fallback to mid_block, if current position is not available
    document.getElementById('position-to-use').innerHTML = '';  // clear options
    Object.keys(current_model.representations).forEach(position => {
      // setup available positions (where the representations are extracted from)
      createElem('option', { value: position, textContent: position == 'mid_block' ? 'mid_block (h-space)' : position, selected: position == current_position }, document.getElementById('position-to-use'));
    });
}


function updateModelDescription() {
  const { steps, m, n} = current_model.getShapes();
  document.getElementById('model-description').textContent = `The examples below are the output for ${current_model.name} at position ${current_position} in the diffusion unet, which has a dimension of (${steps},${m},${n},${n}), i.e. ${steps} steps, ${m} channels, and ${n}x${n} spatial resolution.`;
};


// get mouse/touch position on canvas
function getMousePos(canvas, event) {
  const { n } = current_model.getShapes();
  if (event.touches) event = event.touches[0];  // handle touch events for mobile
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  const col = Math.floor(2 * x / canvas.width * n);
  const row = Math.floor(2 * y / canvas.width * n);
  return { col, row };
}


function init() {
  // load available prompts/concepts
  const prompts_promise = fetch('representations/prompts.json')
    .then(response => response.json())
    .then(data => {
      Object.entries(data).forEach(([name, prompt], i) => {
        available_concepts.push({ name, prompt});
      });
    })
    .catch(error => console.error('Error while fetching prompts info:', error));
  
  // load available models
  const models_promise = fetch('representations/models.json')
    .then(response => response.json())
    .then(data => {
      available_models.push(...data);
      available_models.forEach(model => {
        createElem('option', { value: model.short, textContent: model.short }, document.getElementById('model-to-use'));
        model.getShapes = () => ({ steps: model.steps, m: model.representations[current_position].channels, n: model.representations[current_position].spatial })
      });
      current_model = available_models[0];
      updatePositionSelector();
      updateModelDescription();
    })
    .catch(error => console.error('Error while fetching models info:', error));
  
  // initialize concepts
  Promise.all([prompts_promise, models_promise])
    .then(() => {
      // check if there are any concepts
      if (available_concepts.length === 0) {
        createElem('p', { textContent: 'Error loading Data' }, document.getElementById('canvas-container'));
        return;
      }
      // setup concepts
      initial_concepts.forEach((index, i) => {
        concepts.push(setupConcept(index, i));
      });
    })
    .then(() => {
      // update canvases on load with a delay
      setTimeout(updateCanvasesWithLastClicked, 100);
    });
  
  // setup model change event listener
  document.getElementById('model-to-use').addEventListener('change', event => {
    const prev_hspace_spatial = current_model.getShapes().n;

    // update current model, position selector, and description
    current_model = available_models.find(x => x.short === event.target.value);
    updatePositionSelector();
    updateModelDescription();

    // update last clicked if spatial resolution changed
    const { n } = current_model.getShapes();
    if (n !== prev_hspace_spatial) {
      last_clicked.col = Math.floor(last_clicked.col * n / prev_hspace_spatial);
      last_clicked.row = Math.floor(last_clicked.row * n / prev_hspace_spatial);
    }

    // update concepts and canvases
    concepts.forEach(concept => concept.update());
    updateCanvasesWithLastClicked();
  });

  // setup position change event listener
  document.getElementById('position-to-use').addEventListener('change', event => {
    const prev_hspace_spatial = current_model.getShapes().n;

    // update current position and description
    current_position = event.target.value;
    updateModelDescription();

    // update last clicked if spatial resolution changed
    const { n } = current_model.getShapes();
    if (n !== prev_hspace_spatial) {
      last_clicked.col = Math.floor(last_clicked.col * n / prev_hspace_spatial);
      last_clicked.row = Math.floor(last_clicked.row * n / prev_hspace_spatial);
    }

    // update concepts and canvases
    concepts.forEach(concept => concept.update());
    updateCanvasesWithLastClicked();
  });

  // setup similarity measure change event listener
  document.getElementById('similarity-measure').addEventListener('change', updateCanvasesWithLastClicked);

  // reload on resize to update canvas size
  window.addEventListener('resize', () => {
      concepts.forEach(concept => {
        const canvas_size = concept.image_ctx.canvas.parentElement.clientWidth * 2;
        concept.image_canvas.width = canvas_size;
        concept.image_canvas.height = canvas_size;
        concept.tile_canvas.width = canvas_size;
        concept.tile_canvas.height = canvas_size;
      });
      updateCanvasesWithLastClicked();
  });
}


// start the app
init();

</script>

</body>
</html>
