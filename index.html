<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>H-Space similarity explorer</title>
<style>
  * {
    margin: 0;
    padding: 0;
    font-family: Arial, sans-serif;
  }
  #intro {
    margin: 1em auto 2em auto;
    width: 100%;
    max-width: 800px;
  }
  #intro p {
    margin: 1em;
    line-height: 1.2em;
  }
  #canvas-container {
    margin: 0 auto;
    margin-bottom: 2em;
    width: 100%;
    max-width: 800px;
  }
  #canvas-container h2 {
    text-align: center;
    margin: 2em 0 0 0;
  }
  #canvas-container h2 select {
    margin: 1em;
  }
  #canvas-container>p {
    text-align: center;
    color: grey;
  }
  #canvas-container div {
    width: 100%;
  }
  #canvas-container div div {
    display: inline-block;
    max-width: 44.9%;
    margin: 0 2.5%;
  }
  #canvas-container p {
    text-align: center;
    margin-bottom: .2em;
  }
  #canvas-container p input {
    margin: 0 .5em 0 .5em;
    height: .8em;
    max-width: 80%;
  }
  canvas {
    border: 1px solid #000;
    max-width: 100%;
    height: auto;
    display: block;
    touch-action: none;
  }
</style>
</head>
<body>
  <div id="intro">
    <h1 style="text-align: center;">H-Space similarity explorer</h1>
    <p>
      This is a simple tool to explore the similarity between the representations of different concepts at different spatial positions in the h-space of diffusion models.
      If you want to try this for your own prompts, check out the source code <a href="https://github.com/JonasLoos/h-space-similarity-explorer">here</a>.
    </p>
    <p>
      Model:
      <select id="model-to-use">
      </select>
      Similarity measure:
      <select id="similarity-measure">
        <option value="cosine">Cosine</option>
        <option value="euclidean">Euclidean</option>
        <option value="manhattan">Manhattan</option>
      </select>
    </p>
    <p id="model-description">
    </p>
    <p>
      All displayed similarities are relative to the currently hovered, or last clicked, tile.
    </p>
  </div>
  <div id="canvas-container"></div>
  <script>

// initialize variables
let last_tile = null;  // remember the last tile to avoid redundant updates
let last_clicked = { concept_id: 0, col: 0, row: 0 };  // remember the last clicked tile
const available_models = [];
let current_model = null;
const available_concepts = [];
const concepts = [];
const initial_concepts = [
  { index: 0, initial_step: 50, },
  { index: 1, initial_step: 50, },
  { index: 1, initial_step: 32, },
];


// create an html element with attributes and append it to a parent
function createElem(tag, attrs, parent) {
  const elem = document.createElement(tag);
  for (const [key, value] of Object.entries(attrs)) {
    elem[key] = value;
  }
  parent.appendChild(elem);
  return elem;
}


// setup a concept with its canvas elements and event listeners
function setupConcept({ index, initial_step }, i) {
  const { name, prompt } = available_concepts[index];
  const concept = { id: i, name: name, step: initial_step };
  // create html elements
  const canvas_container = document.getElementById('canvas-container');
  const title_elem = createElem('h2', {}, canvas_container)
  const title_text = createElem('span', { textContent: name }, title_elem);
  const title_select = createElem('select', { id: `concept-${i}-select` }, title_elem);
  available_concepts.forEach((concept, i) => {
    const option = createElem('option', { value: concept.name, textContent: concept.name }, title_select);
    if (concept.name === name) option.selected = true;
  });
  const prompt_p = createElem('p', { textContent: `Prompt: ${prompt}` }, canvas_container);
  const canvas_row = createElem('div', {}, canvas_container);
  const image_canvas_div = createElem('div', {}, canvas_row);
  const canvas_size = image_canvas_div.clientWidth * 2;
  const title_p = createElem('p', {}, image_canvas_div);
  createElem('span', { textContent: `Image at step:` }, title_p);
  const slider = createElem('input', { type: 'range', min: '1', max: '50', value: concept.step }, title_p);
  const slider_value = createElem('span', { textContent: concept.step }, title_p);
  concept.image_canvas = createElem('canvas', { width: canvas_size, height: canvas_size }, image_canvas_div);
  const tile_canvas_div = createElem('div', {}, canvas_row);
  const text_p = createElem('p', {}, tile_canvas_div);
  createElem('span', { textContent: `Similarities, avg: ` }, text_p);
  concept.text = createElem('span', { textContent: `?` }, text_p);
  concept.tile_canvas = createElem('canvas', { width: canvas_size, height: canvas_size }, tile_canvas_div);

  // get convas contexts
  concept.image_ctx = concept.image_canvas.getContext('2d');
  concept.tile_ctx = concept.tile_canvas.getContext('2d');


  const getRepr = () => {
    concept.repr = null;
    fetch(`representations/${current_model.short}/${concept.name}/repr.bin`)
      .then(response => response.arrayBuffer())
      .then(buffer => {
        const repr = new Float32Array(buffer);
        const num_nans = repr.reduce((a, b) => a + (isNaN(b) ? 1 : 0), 0);
        console.log(`Fetched repr for ${concept.name} with length ${repr.length} with ${num_nans} NaNs`);
        concept.repr = repr;
        updateCanvasesWithLastClicked();
      });
  };

  // update
  concept.update = () => {
    // setup prompt related elements
    const prompt = available_concepts.find(x => x.name === concept.name).prompt;
    title_text.textContent = concept.name;
    prompt_p.textContent = prompt;

    // update slider
    concept.step = Math.max(Math.round(concept.step / slider.max * current_model.steps), 1)  // update step to match new model
    slider.max = current_model.steps;
    slider.value = concept.step;
    slider_value.textContent = concept.step;

    // update image und representation
    concept.img.src = `representations/${current_model.short}/${concept.name}/${concept.step}.png`;
    getRepr();
  }

  // load image
  concept.img = new Image();  
  concept.img.src = `representations/${current_model.short}/${concept.name}/${concept.step}.png`;
  concept.img.onload = function() {
    concept.image_ctx.globalCompositeOperation = 'destination-over';
    concept.image_ctx.drawImage(concept.img, 0, 0, concept.image_ctx.canvas.width, concept.image_ctx.canvas.height);
    concept.image_ctx.globalCompositeOperation = 'source-over';
    updateCanvasesWithLastClicked();
  }

  // load representation
  getRepr();

  // setup event listeners  
  [concept.image_canvas, concept.tile_canvas].forEach(canvas => {
    const moveHandler = function(event) {
      const { col, row } = getMousePos(canvas, event);
      updateCanvases(concept, col, row);
    };
    const leaveHandler = function(event) {
      updateCanvases(concepts[last_clicked.concept_id], last_clicked.col, last_clicked.row);
    };
    const clickHandler = function(event) {
      const { col, row } = getMousePos(canvas, event);
      last_clicked.concept_id = concept.id;
      last_clicked.col = col;
      last_clicked.row = row;
      last_tile = null;  // force update
      updateCanvases(concept, col, row);
    };
    canvas.addEventListener('click', clickHandler);
    canvas.addEventListener('mousemove', moveHandler);
    canvas.addEventListener('mouseleave', leaveHandler);
    canvas.addEventListener('touchstart', clickHandler);
    canvas.addEventListener('touchmove', clickHandler);
  });
  
  // slider event listener
  slider.addEventListener('input', event => {
    const value = event.target.value;
    slider_value.textContent = value;
    concept.step = value;
    concept.img.src = `representations/${current_model.short}/${concept.name}/${concept.step}.png`;
    updateCanvasesWithLastClicked();
  });

  // concept name select event listener
  title_select.addEventListener('change', event => {
    const value = event.target.value;
    concept.name = value;
    concept.update();
  });

  // concept is ready
  return concept;
}



function cosineSimilarity(repr1, offset1, repr2, offset2) {
  const n = current_model.hspace_spatial;
  const m = current_model.hspace_channels;
  let dotProduct = 0.0;
  let normA = 0.0;
  let normB = 0.0;

  for (let i = 0; i < m; i++) {
    const i1 = offset1 + i*n*n;
    const i2 = offset2 + i*n*n;
    // if (i1 >= 81920 || i2 >= 81920) {
    //   console.error(`index too high: i1: ${i1}, i2: ${i2}`);
    // }
    // if (isNaN(repr1[i1]) || isNaN(repr2[i2])) {
    //   console.error(`NaN: i1: ${i1}, i2: ${i2}, repr1[i1]: ${repr1[i1]}, repr2[i2]: ${repr2[i2]}`);
    // }
    dotProduct += repr1[i1] * repr2[i2];
    normA += repr1[i1] * repr1[i1];
    normB += repr2[i2] * repr2[i2];
  }

  normA = Math.sqrt(normA);
  normB = Math.sqrt(normB);

  if (normA === 0 || normB === 0) {
    throw new Error('One of the vectors is zero');
  }

  return dotProduct / (normA * normB);
}


function euclideanDistance(repr1, offset1, repr2, offset2) {
  const n = current_model.hspace_spatial;
  const m = current_model.hspace_channels;
  let sum = 0.0;
  for (let i = 0; i < m; i++) {
    const i1 = offset1 + i*n*n;
    const i2 = offset2 + i*n*n;
    sum += Math.pow(repr1[i1] - repr2[i2], 2);
  }

  return Math.sqrt(sum);
}


function manhattanDistance(repr1, offset1, repr2, offset2) {
  const n = current_model.hspace_spatial;
  const m = current_model.hspace_channels;
  let sum = 0.0;
  for (let i = 0; i < m; i++) {
    const i1 = offset1 + i*n*n;
    const i2 = offset2 + i*n*n;
    sum += Math.abs(repr1[i1] - repr2[i2]);
  }
  return sum;
}


// calculate similarities based on the selected similarity measure and tile
function calcSimilarities(base_concept, col, row, concept) {
  const n = current_model.hspace_spatial;
  const m = current_model.hspace_channels;
  const step1 = base_concept.step - 1;
  const step2 = concept.step - 1;

  // check if representations are loaded
  if (!base_concept.repr || !concept.repr) {
    console.log(`Representations not loaded (base_concept: ${!!base_concept.repr}, other concept: ${!!concept.repr})`);
    return Array(n*n).fill(0);
  }

  // helper function to calculate similarities for all tiles
  const calc = measure => {
    const x = [];
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        const offset1 = step1*m*n*n + row*n + col;
        const offset2 = step2*m*n*n + j*n + i;
        const similarity = measure(base_concept.repr, offset1, concept.repr, offset2);
        x.push(similarity);
      }
    }
    return x;
  }

  // calculate similarities
  const measure_str = document.getElementById('similarity-measure').value;
  if (measure_str === 'cosine') {
    return calc(cosineSimilarity);
  } else if (measure_str === 'euclidean') {
    const differences =  calc(euclideanDistance);
    const max = Math.max(...differences);
    return differences.map(x => 1 - x / max);
  } else if (measure_str === 'manhattan') {
    const differences = calc(manhattanDistance);
    const max = Math.max(...differences);
    return differences.map(x => 1 - x / max);
  }
}



// Utility function to load an image
function loadImage(ctx, img) {
  ctx.drawImage(img, 0, 0, ctx.canvas.width, ctx.canvas.height);
}

// Function to draw the grid
function drawGrid(ctx) {
  const tile_size = ctx.canvas.width / current_model.hspace_spatial;
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 2;
  ctx.beginPath();

  // Draw the vertical lines
  for (let i = 1; i < current_model.hspace_spatial; i++) {
    ctx.moveTo(i * tile_size, 0);
    ctx.lineTo(i * tile_size, ctx.canvas.height);
  }

  // Draw the horizontal lines
  for (let i = 1; i < current_model.hspace_spatial; i++) {
    ctx.moveTo(0, i * tile_size);
    ctx.lineTo(ctx.canvas.width, i * tile_size);
  }

  ctx.stroke();
}


// Event listener for mouse movement over canvas
function updateCanvases(base_concept, col, row) {
  const n = current_model.hspace_spatial;
  // Check if the mouse is inside the canvas
  if (col < 0 || col >= n || row < 0 || row >= n) return;

  // Check if the tile has changed
  const curr_tile = `${base_concept.id}-${col}-${row}`;
  if (curr_tile === last_tile) return;
  last_tile = curr_tile;

  // Update the canvases
  for (const concept of concepts) {
    const tile_size = concept.image_ctx.canvas.width / n;
    // update image canvas
    const img_ctx = concept.image_ctx;
    img_ctx.clearRect(0, 0, img_ctx.canvas.width, img_ctx.canvas.height);
    loadImage(img_ctx, concept.img);
    drawGrid(img_ctx);
    if (concept === base_concept) {
      img_ctx.strokeStyle = 'rgba(255, 165, 0, 1)';
      img_ctx.lineWidth = 2;
      img_ctx.strokeRect(col * tile_size, row * tile_size, tile_size, tile_size);
      img_ctx.fillStyle = 'rgba(255, 165, 0, 0.7)';
      img_ctx.fillRect(col * tile_size, row * tile_size, tile_size, tile_size);
    }
    if (last_clicked.concept_id === concept.id && !(last_clicked.col === col && last_clicked.row === row && concept === base_concept)) {
      img_ctx.fillStyle = 'rgba(255, 165, 165, 0.7)';
      img_ctx.fillRect(last_clicked.col * tile_size, last_clicked.row * tile_size, tile_size, tile_size);
    }
    // update tile canvas
    const similarities = calcSimilarities(base_concept, col, row, concept);
    concept.tile_ctx.clearRect(0, 0, concept.tile_ctx.canvas.width, concept.tile_ctx.canvas.height);
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        const similarity = similarities[i * n + j];
        concept.tile_ctx.fillStyle = similarity > 0 ? `rgba(255, 165, 0, ${similarity})` : `rgba(0, 165, 255, ${-similarity})`;
        concept.tile_ctx.fillRect(i * tile_size, j * tile_size, tile_size, tile_size);
      }
    }

    // calculate and update average similarity
    const averageSimilarity = similarities.reduce((a, b) => a + b, 0) / similarities.length;
    concept.text.textContent = `${averageSimilarity.toFixed(4)}`;
  }
}


// force update of all canvases with the last clicked tile as the base
function updateCanvasesWithLastClicked() {
  last_tile = null;  // force update
  updateCanvases(concepts[last_clicked.concept_id], last_clicked.col, last_clicked.row);
}



function updateModelDescription(model) {
  document.getElementById('model-description').textContent = `The examples below are for ${model.name}, which has a h-space dimension of (${model.steps},${model.hspace_channels},${model.hspace_spatial},${model.hspace_spatial}), i.e. ${model.steps} steps, ${model.hspace_channels} channels, and ${model.hspace_spatial}x${model.hspace_spatial} spatial resolution.`;
};


// get mouse/touch position on canvas
function getMousePos(canvas, event) {
  if (event.touches) event = event.touches[0];  // handle touch events for mobile
  const rect = canvas.getBoundingClientRect();
  const x = event.clientX - rect.left;
  const y = event.clientY - rect.top;
  const col = Math.floor(2 * x / canvas.width * current_model.hspace_spatial);
  const row = Math.floor(2 * y / canvas.width * current_model.hspace_spatial);
  return { col, row };
}


function init() {
  // load available prompts/concepts
  const prompts_promise = fetch('representations/prompts.json')
    .then(response => response.json())
    .then(data => {
      Object.entries(data).forEach(([name, prompt], i) => {
        available_concepts.push({ name, prompt});
      });
    })
  
  // load available models
  const models_promise = fetch('representations/models.json')
    .then(response => response.json())
    .then(data => {
      available_models.push(...data);
      available_models.forEach(model => {
        createElem('option', { value: model.short, textContent: model.short }, document.getElementById('model-to-use'));
      });
      current_model = available_models[0];
      updateModelDescription(current_model);
    })
  
  // initialize concepts
  Promise.all([prompts_promise, models_promise])
    .then(() => {
      initial_concepts.forEach((index, i) => {
        concepts.push(setupConcept(index, i));
      });
    })
    .then(() => {
      // update canvases on load with a delay
      setTimeout(updateCanvasesWithLastClicked, 100);
    });
  
  // setup model change event listener
  document.getElementById('model-to-use').addEventListener('change', event => {
    const model = available_models.find(x => x.short === event.target.value);
    current_model = model;
    updateModelDescription(model);
    concepts.forEach(concept => concept.update());
    updateCanvasesWithLastClicked();
  });

  // setup similarity measure change event listener
  document.getElementById('similarity-measure').addEventListener('change', updateCanvasesWithLastClicked);

  // reload on resize to update canvas size
  window.addEventListener('resize', () => {
      concepts.forEach(concept => {
        const canvas_size = concept.image_ctx.canvas.parentElement.clientWidth * 2;
        concept.image_canvas.width = canvas_size;
        concept.image_canvas.height = canvas_size;
        concept.tile_canvas.width = canvas_size;
        concept.tile_canvas.height = canvas_size;
        loadImage(concept.image_ctx, concept.img);
        drawGrid(concept.image_ctx);
        updateCanvases(concept, last_clicked.col, last_clicked.row);
      });
  });
}


// start the app
init();

</script>

</body>
</html>
